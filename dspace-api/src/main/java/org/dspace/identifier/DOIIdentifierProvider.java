/**
 * The contents of this file are subject to the license and copyright
 * detailed in the LICENSE and NOTICE files at the root of the source
 * tree and available online at
 *
 * http://www.dspace.org/license/
 */

package org.dspace.identifier;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import org.dspace.authorize.AuthorizeException;
import org.dspace.content.DCValue;
import org.dspace.content.DSpaceObject;
import org.dspace.content.FormatIdentifier;
import org.dspace.content.Item;
import org.dspace.core.Context;
import org.dspace.identifier.doi.DOIConnector;
import org.dspace.storage.rdbms.DatabaseManager;
import org.dspace.storage.rdbms.TableRow;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Required;

/**
 * Provide service for DOIs using DataCite.
 * 
 * <p>This class handles reservation, registration and deletion of DOIs using
 * the direct API from {@link <a href="http://www.datacite.org">DataCite</a>}.
 * Please pay attention that some members of DataCite offers special services
 * and wants their customers to use special APIs. If you are unsure ask your
 * registration agency.</p>
 * 
 * <p>Any identifier a method of this class returns as a string is in the
 * following format: doi:10.123/456.</p>
 * 
 * @author Pascal-Nicolas Becker
 */
public class DOIIdentifierProvider
    extends IdentifierProvider
{
    /*
     * TODOs:
     *  - better exception handling
     *  - search this file for TODOs an FIXMEs
     *  - set DataCiteConnector.reseverDOI(...) and comparable methods to return void
     *  - make an interface for DataCiteConnector
     */
    
    private static final Logger log = LoggerFactory.getLogger(DOIIdentifierProvider.class);
    
    static final String CFG_PREFIX = "identifier.doi.prefix";
    static final String CFG_NAMESPACE_SEPARATOR = "identifier.doi.namespaceseparator";
        
    // Metadata field name elements
    // TODO: move these to MetadataSchema or some such?
    public static final String MD_SCHEMA = "dc";
    public static final String DOI_ELEMENT = "identifier";
    public static final String DOI_QUALIFIER = null;
    
    /**
     * Prefix of DOI namespace. Set in dspace.cfg.
     */
    private String PREFIX;
    
    /**
     * Part of DOI to separate several applications that generate DOIs. F.e. it
     * could be 'dspace/' if DOIs generated by DSpace should have the form
     * prefix/dspace/uniqueString. Set it to the empty String if DSpace should
     * generate DOIs directly after the DOI Prefix. Set in dspace.cfg.
     */
    private String NAMESPACE_SEPARATOR;
    
    protected String getPrefix()
    {
        if (null == this.PREFIX)
        {
            this.PREFIX = this.configurationService.getProperty(CFG_PREFIX);
            if (null == this.PREFIX)
            {
                log.warn("Cannot find DOI prefix in configuration!");
                throw new RuntimeException("Unable to load DOI prefix from "
                        + "configuration. Cannot find property " +
                        CFG_PREFIX + ".");
            }
        }
        return this.PREFIX;
    }
    
    protected String getNamespaceSeparator()
    {
        if (null == this.NAMESPACE_SEPARATOR)
        {
            this.NAMESPACE_SEPARATOR = this.configurationService.getProperty(CFG_NAMESPACE_SEPARATOR);
            if (null == this.NAMESPACE_SEPARATOR)
            {
                this.NAMESPACE_SEPARATOR = "";
            }
        }
        return this.NAMESPACE_SEPARATOR;
    }

    
    private DOIConnector connector;
    
    @Required
    public void setDOIConnector(DOIConnector connector)
    {
        this.connector = connector;
    }
    
    /**
     * This identifier provider supports identifiers of type
     * {@link org.dspace.identifier.DOI}.
     * @param identifier to check if it will be supported by this provider.
     * @return 
     */
    @Override
    public boolean supports(Class<? extends Identifier> identifier)
    {
        return DOI.class.isAssignableFrom(identifier);
    }
    
    /**
     * This identifier provider supports identifiers in the following format:
     * <ul>
     *  <li>doi:10.123/456</li>
     *  <li>10.123/456</li>
     *  <li>http://dx.doi.org/10.123/456</li>
     * </ul>
     * @param identifier to check if it is in a supported format.
     * @return 
     */
    @Override
    public boolean supports(String identifier)
    {
        try {
            formatIdentifier(identifier);
        } catch (IdentifierException e) {
            return false;
        }
            return true;
    }

    
    @Override
    public String register(Context context, DSpaceObject dso)
            throws IdentifierException
    {
        String doi = mint(context, dso);
        // register tries to reserve doi if it's not already.
        // So we don't have to reserve it here.
        this.register(context, dso, doi);
        return doi;
    }

    @Override
    public void register(Context context, DSpaceObject dso, String identifier)
            throws IdentifierException
    {
        this.registerDOI(context, dso, identifier);
    }
    
    private void registerDOI(Context context, DSpaceObject dso, String identifier)
            throws IdentifierException
    {
        String doi = formatIdentifier(identifier);

        // check if the DOI is already registered for this dso
        if (connector.isDOIRegistered(context, dso, doi))
            return;

        // check if DOI is registered for another object
        if (connector.isDOIRegistered(context, doi))
        {
            log.warn("Trying to register DOI {}, that is already registered.", doi);
            throw new IdentifierException("Trying to register a DOI that is "
                    + "registered for another object.");
        }
        
        // check if doi is reserved for this specific dso
        if (!connector.isDOIReserved(context, dso, doi))
        {
            // check if doi is already reserved for another dso
            if (connector.isDOIReserved(context, doi))
            {
                log.warn("Trying to register DOI {}, that is reserved for "
                        + "another dso.", doi);
                throw new IdentifierException("Trying to register a DOI " +
                        "that is reserved for another object.");
            }
            
            
            if(!connector.reserveDOI(context, dso, doi))
            {
                throw new IdentifierException("It was impossible to reserve the DOI "
                        + doi + ". Take a look into the logs for further details.");
            }
        }
        
        try
        {
            if (!connector.registerDOI(context, dso, doi))
            {
                throw new IdentifierException("It was impossible to register the DOI "
                    + doi + ". Take a look into the logs for further details.");
            }
        }
        //FIXME add better exception handling
        catch (Exception e)
        {
            throw new IdentifierException(e);
        }

        try {
            saveDOIToObject(context, dso, doi);
        }
        //FIXME add better exception handling
        catch (Exception e)
        {
            throw new IdentifierException(e);
        }

    }

    /**
     * @param context
     * @param dso DSpaceObject the DOI should be reserved for. Some metadata of
     *            this object will be send to the registration agency.
     * @param identifier DOI to register in a format that
     *                   {@link FormatIdentifier(String)} accepts.
     * @throws IdentifierException If the format of {@code identifier} was
     *                             unrecognized or if it was impossible to 
     *                             reserve the DOI (registration agency denied 
     *                             for some reason, see logs).
     * @throws IllegalArgumentException If {@code identifier} is a DOI already
     *                                  registered for another DSpaceObject then
     *                                  {@code dso}.
     * @see IdentifierProvider.reserve(Context, DSpaceObject, String)
     */
    @Override
    public void reserve(Context context, DSpaceObject dso, String identifier)
            throws IdentifierException, IllegalArgumentException
    {
        this.reserveDOI(context, dso, identifier);
    }
    
    private void reserveDOI(Context context, DSpaceObject dso, String identifier)
            throws IdentifierException, IllegalArgumentException
    {
        String doi = formatIdentifier(identifier);
        
        // ensure that the DOI is in our DOI table and is not reserved online
        // for another object than dso
        try {
            createNewIdentifier(context, dso, doi);
        }
        catch (IllegalArgumentException ex)
        {
            throw new IdentifierException("DOI is reserved for another object.");
        }
        catch (SQLException ex)
        {
            throw new RuntimeException("Error in database connection: " + ex.getMessage());
        }
        
        // check if DOI is reserved at the registration agency for the specific dso
        if (!connector.isDOIReserved(context, dso, doi))
        {
            // check if doi is already reserved for another object
            if (connector.isDOIReserved(context, doi))
            {
                log.warn("Trying to reserve a DOI {} that is reserved for "
                        + "another object.", doi);
                throw new IdentifierException("Trying to reserve a DOI " +
                        "that is reserved for another object.");
            }
            // try to reserve the doi
            if(!connector.reserveDOI(context, dso, doi))
            {
                throw new IdentifierException("It was impossible to reserve the DOI "
                        + doi + ". Take a look into the logs for further details.");
            }
        }
    }
    
    @Override
    public String mint(Context context, DSpaceObject dso)
            throws IdentifierException
    {
        String doi = null;
        try
        {
            doi = getDOIByObject(context, dso);
        }
        catch (SQLException e)
        {
            log.error("Error while attemping to retrieve information about a DOI for "
                    + dso.getTypeText() + " with ID " + dso.getID() + ".");
            throw new RuntimeException("Error while attemping to retrieve " +
                    "information about a DOI for " + dso.getTypeText() + 
                    " with ID " + dso.getID() + ".", e);
        }
        if (null == doi)
        {
            try
            {
                doi = createNewIdentifier(context, dso, null);
            }
            catch (SQLException e)
            {
                log.error("Error while creating new DOI for Object of " +
                        "ResourceType {} with id {}.", dso.getType(), dso.getID());
                throw new RuntimeException("Error while attemping to create a " +
                        "new DOI for " + dso.getTypeText() + " with ID " + 
                        dso.getID() + ".", e);
            }
        }
        return doi;
    }

    @Override
    public DSpaceObject resolve(Context context, String identifier, String... attributes)
            throws IdentifierNotFoundException, IdentifierNotResolvableException
    {
        String doi = null;
        try {
            doi = formatIdentifier(identifier);
        } catch (IdentifierException e) {
            throw new IdentifierNotResolvableException(e.getMessage());
        }
        try
        {
            return getObjectByDOI(context, doi);
        }
        catch (SQLException e)
        {
            throw new RuntimeException("Unable to retrieve information about "+
                    "a DOI out of database.", e);
        }
        catch (IdentifierException e)
        {
            throw new IdentifierNotResolvableException(e);
        }
    }

    @Override
    public String lookup(Context context, DSpaceObject dso)
            throws IdentifierNotFoundException, IdentifierNotResolvableException
    {
        String doi = null;
        try
        {
            doi = getDOIByObject(context, dso);
        }
        catch (SQLException e)
        {
            throw new RuntimeException("Error retrieving DOI out of database.", e);
        }
        
        if (null == doi)
            throw new IdentifierNotFoundException("No DOI for DSpaceObject of type "
                    + dso.getTypeText() + " with ID " + dso.getID() + " found.");
        
        return doi;
    }

    @Override
    public void delete(Context context, DSpaceObject dso)
            throws IdentifierException
    {
        String doi = null;
        try {
            doi = getDOIByObject(context, dso);
        }
        catch (SQLException e)
        {
            log.error("Error while attemping to retrieve information about a DOI for "
                    + dso.getTypeText() + " with ID " + dso.getID() + ".");
            log.error(e.getMessage());
            throw new RuntimeException("Error while attemping to retrieve " +
                    "information about a DOI for " + dso.getTypeText() + 
                    " with ID " + dso.getID() + ".", e);
        }
        this.delete(context, dso, doi);
    }

    @Override
    public void delete(Context context, DSpaceObject dso, String identifier)
            throws IdentifierException
    {
            deleteDOI(context, dso, identifier);
    }

    private void deleteDOI(Context context, DSpaceObject dso, String identifier)
        throws IdentifierException
    {
        log.debug("delete {} from {}", identifier, dso);
        String doi = formatIdentifier(identifier);
        log.debug("formated identifier as {}", doi);
        
        if (connector.isDOIRegistered(context, doi))
            throw new IdentifierException("Unable to delete DOI " + doi +
                    ". It is already registered.");
        
        // look for doi in DB
        // if it exists compare resource type and id
        // if not okay throw exception

        try {
            removeDOIFromObject(context, dso, doi);
        }
        catch (AuthorizeException ex)
        {
            log.error("Not authorized to delete a DOI out of an Item.");
            throw new IdentifierException("Not authorized to delete DOI.", ex);
        }
        catch (SQLException ex)
        {
            log.error("SQLException occured while deleting a DOI out of an item: "
                    + ex.getMessage());
            throw new RuntimeException("Error while deleting a DOI out of the " +
                    "metadata of an Item " + dso.getID(), ex);
        }
        
        
        // DataCiteConnector.deleteDOI(String doi)
        // delete doi from database
        
        //if (!deleteDOI(context, dso, doi))
        if (false)
        {
            // It was not possible to delete a DOI at the registry agency. We
            // already removed the DOI out of the metadata of the object,
            // so we should restore these information.
            try
            {
                saveDOIToObject(context, dso, doi);
            }
            catch (AuthorizeException e)
            {
                log.error("We were authorized to delete a DOI out of an Item, " +
                        "but we can't restore these informations?!");
                log.error("DSO-Type: " + dso.getTypeText() + ", ID: " + 
                        dso.getID() + ", DOI: " + doi + ".");
                throw new IllegalStateException("We were authorized to delete " +
                        "a DOI out of an Item, but we can't restore these informations?!", e);
            }
            catch (SQLException ex)
            {
                log.error("SQLError while restoring DOI " + doi +
                        " for Object of Type " + dso.getTypeText() + " with ID "
                        + dso.getID() + ".");
                log.error("Exception message: " + ex.getMessage());
                throw new RuntimeException("Error while restoring a DOI as " +
                        "metadata of an Item " + dso.getID(), ex);
            }
            throw new IdentifierException("Unable to delete DOI " + doi +
                    ". Take a look into the logs for further details.");
        }
        log.info("Deleted {}", doi);
    }

    
    /**
     * Recognize format of DOI and return it with leading doi-Scheme.
     * @param identifier Identifier to format, following format are accepted:
     *                   f.e. 10.123/456, doi:10.123/456, http://dx.doi.org/10.123/456.
     * @return Given Identifier with DOI-Scheme, f.e. doi:10.123/456.
     * @throws IllegalArgumentException If identifier is empty or null.
     * @throws IdentifierException If DOI could not be recognized.
     */
    public static String formatIdentifier(String identifier) throws IdentifierException
    {
        if (null == identifier) 
            throw new IllegalArgumentException("Identifier is null.", new NullPointerException());
        if (identifier.startsWith("doi:"))
            return identifier;
        if (identifier.isEmpty())
            throw new IllegalArgumentException("Cannot format an empty identifier.");
        if (identifier.startsWith("10.") && identifier.contains("/"))
            return DOI.SCHEME + identifier;
        if (identifier.startsWith("http://dx.doi.org/10."))
            return DOI.SCHEME + identifier.substring(18);
        throw new IdentifierException(identifier + "does not seem to be a DOI.");
    }
    
     
    /**
     * Returns a DSpaceObject depending on its DOI.
     * @param context the context
     * @param identifier The DOI in a format that is accepted by
     *                   {@link formatIdentifier(String)}.
     * @return Null if the DOI couldn't be found or the associated DSpaceObject.
     * @throws SQLException
     * @throws IdentifierException If {@code identifier} is null or an empty string.
     * @throws IllegalArgumentException If the identifier couldn't be recognized as DOI.
     */
    public static DSpaceObject getObjectByDOI(Context context, String identifier)
            throws SQLException, IdentifierException, IllegalArgumentException
    {
        String doi = formatIdentifier(identifier);
        TableRow doiRow = DatabaseManager.findByUnique(context, "Doi", "doi", doi);
        
        if (null == doiRow)
            return null;
        
        if (doiRow.isColumnNull("resource_type_id") ||
                doiRow.isColumnNull("resource_id"))
        {
            throw new IllegalStateException("Found DOI " + doi +
                    " in database, but no assigned Object could be found.");
        }
        
        return DSpaceObject.find(context,
                doiRow.getIntColumn("resource_type_id"),
                doiRow.getIntColumn("resource_id"));
    }
    
    /**
     * Search the database for a DOI, using the type and id of an DSpaceObject.
     * 
     * @param context
     * @param dso DSpaceObject to find doi for.
     * @return The DOI as String or null if DOI was not found.
     * @throws SQLException 
     */
    public static String getDOIByObject(Context context, DSpaceObject dso)
            throws SQLException
    {
        String sql = "SELECT * FROM Doi WHERE resource_type_id = ? " +
                "AND resource_id = ?";

        TableRow doiRow = DatabaseManager.querySingleTable(context,
                "Doi", sql, dso.getType(), dso.getID());
        if (null == doiRow)
            return null;

        if (doiRow.isColumnNull("doi"))
        {
            log.error("A DOI with an empty doi column was found in the database. DSO-Type: "
                    + dso.getTypeText() + ", ID: " + dso.getID() + ".");
            throw new IllegalStateException("A DOI with an empty doi column " +
                    "was found in the database. DSO-Type: " + dso.getTypeText() + 
                    ", ID: " + dso.getID() + ".");
        }
        
        return DOI.SCHEME + doiRow.getStringColumn("doi");
    }
    
    /**
     * Creates a new DOI and saves it into the database.
     * 
     * @param context
     * @param dso The DSpaceObject the DOI should be created for.
     * @param doi A DOI or null if DOI should be generated.
     * @return The generated DOI or {@code doi} if it was saved into the database.
     * @throws SQLException In case of an error using the database.
     * @throws IllegalArgumentException If the given DOI already exists for an other object.
     * @throws IdentifierException If {@code doi} is not part of our prefix or
     *                             the doi registry thinks that the DOI belongs
     *                             to another party.
     */
    protected String createNewIdentifier(Context context, DSpaceObject dso, String doi)
            throws SQLException, IllegalArgumentException, IdentifierException
    {
        TableRow doiRow = null;
        if (null != doi)
        {
            // check if DOI is already in Database
            // remove DOI.SCHEME before searching in DB.
            doiRow = DatabaseManager.findByUnique(context, "Doi",
                    "doi", doi.substring(DOI.SCHEME.length()));
            if (null != doiRow)
            {
                // check if DOI already belongs to dso
                if (doiRow.getIntColumn("resource_id") == dso.getID() &&
                        doiRow.getIntColumn("resource_type_id") == dso.getType())
                {
                    return doi;
                }
                else
                {
                    throw new IllegalArgumentException("Trying to save a DOI " +
                            "that is already reserved for another object.");
                }
            }
            else
            {
                // doi is not null but was not found in db
                // check if it is reserved online for another object
                if (!connector.isDOIReserved(context, dso, doi) &&
                        connector.isDOIReserved(context, doi))
                {
                    throw new IllegalArgumentException("Trying to save a DOI " +
                            "that is already reserved for another object.");
                // safe it to db (see below)
                }
            }
        }
        
        doiRow = DatabaseManager.create(context, "Doi");
        
        if (null != doi)
        {
            doi = doi.substring(DOI.SCHEME.length());
            if (!doi.startsWith(this.getPrefix() + "/"))
                throw new IdentifierException("Trying to create a DOI " +
                        "that's not part of our Namespace!");
        }
        else
            doi = this.getPrefix() + "/" + this.getNamespaceSeparator() + 
                    doiRow.getIntColumn("doi_id");
        
        doiRow.setColumn("doi", doi);
        doiRow.setColumn("resource_type_id", dso.getType());
        doiRow.setColumn("resource_id", dso.getID());
        DatabaseManager.update(context, doiRow);

        return DOI.SCHEME + doi;
    }
    
    public static String getDOIOutOfObject(DSpaceObject dso) {
        // FIXME
        if (!(dso instanceof Item))
            throw new IllegalArgumentException("Unsupported type " + dso.getTypeText());

        Item item = (Item)dso;

        DCValue[] metadata = item.getMetadata(MD_SCHEMA, DOI_ELEMENT, DOI_QUALIFIER, null);
        for (DCValue id : metadata)
        {
            if (!id.value.startsWith(DOI.SCHEME))
                return id.value;
        }
        return null;
    }
    
    /**
     * Adds a DOI to the Metadata of an item.
     * 
     * @param context
     * @param dso DSpaceObject the DOI should be added to.
     * @param doi The DOI that should be added as metadata.
     * @throws SQLException
     * @throws AuthorizeException 
     */
    protected void saveDOIToObject(Context context, DSpaceObject dso, String doi)
            throws SQLException, AuthorizeException
    {
        // FIXME
        if (!(dso instanceof Item))
            throw new IllegalArgumentException("Unsupported type " + dso.getTypeText());
        
        Item item = (Item) dso;
        item.addMetadata(MD_SCHEMA, DOI_ELEMENT, DOI_QUALIFIER, null, doi);
        try
        {
            item.update();
            context.commit();
            log.info("reserved {}", doi);
        } catch (SQLException ex) {
            throw ex;
        } catch (AuthorizeException ex) {
            throw ex;
        }
    }
    
    /**
     * Removes a DOI out of the metadata of a DSpaceObject.
     * 
     * @param context
     * @param dso The DSpaceObject the DOI should be removed from.
     * @param doi The DOI to remove out of the metadata.
     * @throws AuthorizeException
     * @throws SQLException 
     */
    protected void removeDOIFromObject(Context context, DSpaceObject dso, String doi)
            throws AuthorizeException, SQLException
    {
        // FIXME
        if (!(dso instanceof Item))
            throw new IllegalArgumentException("Unsupported type " + dso.getTypeText());

        Item item = (Item)dso;

        DCValue[] metadata = item.getMetadata(MD_SCHEMA, DOI_ELEMENT, DOI_QUALIFIER, null);
        List<String> remainder = new ArrayList<String>();

        for (DCValue id : metadata)
        {
            if (!id.value.equals(doi))
                remainder.add(id.value);
        }

        item.clearMetadata(MD_SCHEMA, DOI_ELEMENT, DOI_QUALIFIER, null);
        item.addMetadata(MD_SCHEMA, DOI_ELEMENT, DOI_QUALIFIER, null,
                remainder.toArray(new String[remainder.size()]));
        try {
            item.update();
            context.commit();
        } catch (SQLException e) {
            throw e;
        } catch (AuthorizeException e) {
            throw e;
        }
    }
}
