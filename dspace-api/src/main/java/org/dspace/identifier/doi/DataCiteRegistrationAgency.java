/**
 * The contents of this file are subject to the license and copyright
 * detailed in the LICENSE and NOTICE files at the root of the source
 * tree and available online at
 *
 * http://www.dspace.org/license/
 */
package org.dspace.identifier.doi;

import java.io.IOException;
import java.sql.SQLException;
import org.dspace.authorize.AuthorizeException;
import org.dspace.content.DCValue;
import org.dspace.content.DSpaceObject;
import org.dspace.content.Item;
import org.dspace.content.crosswalk.CrosswalkException;
import org.dspace.content.crosswalk.DisseminationCrosswalk;
import org.dspace.core.PluginManager;
import org.dspace.identifier.DOI;
import org.dspace.identifier.DOIIdentifierProvider;
import org.dspace.identifier.IdentifierException;
import org.jdom.Document;
import org.jdom.Element;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Required;

/**
 * This class encapsulate the DataCite API to reserve, register and delete DOIs.
 * Please pay attention: some DataCite members (f.e. CDL/EZID, Gesis/re|data),
 * that acts as registration agency provide their own API. This class targets
 * the API of the DataCite metadata store directly. If your not sure weather to
 * use this or another API ask your registration agency.
 *
 * @author Pascal-Nicolas Becker (p dot becker at tu hyphen berlin dot de)
 */
public class DataCiteRegistrationAgency extends RegistrationAgency {
    
    private static final org.slf4j.Logger log = LoggerFactory.getLogger(DataCiteRegistrationAgency.class);
    
    /**
     * Stores the scheme used to connect to the DataCite server. It will be set
     * by spring dependency injection.
     */
    private String DATACITE_SCHEME;
    /**
     * Stores the hostname of the DataCite server. Set by spring dependency
     * injection.
     */
    private String DATACITE_HOST;
    /**
     * Path on the DataCite server used to generate DOIs. Set by spring
     * dependency injection.
     */
    private String DATACITE_DOI_PATH;
    /**
     * Path on the DataCite server used to register metadata. Set by spring
     * dependency injection.
     */
    private String DATACITE_METADATA_PATH;
    /**
     * Name of crosswalk to convert metadata into DataCite Metadata Scheme. Set 
     * by spring dependency injection.
     */
    private String CROSSWALK_NAME;
    
    /**
     * Prefix of DOI namespace. Set in dspace.cfg.
     */
    private String PREFIX;
    /**
     * Part of DOI to seperate several applications that generate DOIs. F.e. it
     * could be 'dspace/' if DOIs generated by DSpace should have the form
     * prefix/dspace/uniqueString. Set it to the empty String if DSpace should
     * generate DOIs directly after the DOI Prefix. Set in dspace.cfg.
     */
    private String NAMESPACE_SEPARATOR;
    
    // TODO: document how exception while initializing the crosswalks will be
    // handeled.
    /** 
     * DisseminationCrosswalk to map local metadata into DataCite metadata.
     * The name of the crosswalk is set by spring dependency injection using
     * {@link setDisseminationCrosswalk(String) setDisseminationCrosswalk} which
     * instantiate the crosswalk.
     */
    protected DisseminationCrosswalk crosswalk;
    
    /**
     * Used to set the scheme to connect the DataCite server. Used by spring
     * dependency injection.
     * @param DATACITE_SCHEME Probably https or http.
     */
    @Required
    public void setDATACITE_SCHEME(String DATACITE_SCHEME) {
        this.DATACITE_SCHEME = DATACITE_SCHEME;
    }

    /**
     * Set the hostname of the DataCite server. Used by spring dependency
     * injection.
     * @param DATACITE_HOST Hostname to connect to register DOIs (f.e. test.datacite.org).
     */
    @Required
    public void setDATACITE_HOST(String DATACITE_HOST) {
        this.DATACITE_HOST = DATACITE_HOST;
    }
    
    /**
     * Set the path on the DataCite server to register DOIs. Used by spring
     * dependency injection.
     * @param DATACITE_DOI_PATH Path to register DOIs, f.e. /doi.
     */
    @Required
    public void setDATACITE_DOI_PATH(String DATACITE_DOI_PATH) {
        this.DATACITE_DOI_PATH = DATACITE_DOI_PATH;
    }
    
    /**
     * Set the path to register metadata on DataCite server. Used by spring
     * dependency injection.
     * @param DATACITE_METADATA_PATH Path to register metadata, f.e. /mds.
     */
    @Required
    public void setDATACITE_METADATA_PATH(String DATACITE_METADATA_PATH) {
        this.DATACITE_METADATA_PATH = DATACITE_METADATA_PATH;
    }
    
    // TODO: document how exception while initializing the crosswalks will be
    // handeled.
    /**
     * Set the name of the dissemination crosswalk used to convert the metadata
     * into DataCite Metadata Schema. This method tries to initialize the named
     * crosswalk. Used by spring dependency injection.
     * @param CROSSWALK_NAME The name of the dissemination crosswalk to use. This
     *                       crosswalk must be configured in dspace.cfg.
     */
    @Required
    public void setDisseminationCrosswalk(String CROSSWALK_NAME) {
        this.CROSSWALK_NAME= CROSSWALK_NAME;

    	// FIXME add some caching here
    	this.crosswalk = (DisseminationCrosswalk) PluginManager.getNamedPlugin(DisseminationCrosswalk.class, CROSSWALK_NAME);
        // FIXME handle the case if the crosswalk can't be found
        if (this.crosswalk == null) {
            throw new IllegalArgumentException("Can't find crosswalk '" + CROSSWALK_NAME + "'!");
        }
    }
    
    public void DataCiteRegistrationAgency() {
        // TODO: get those from configuration service
        this.PREFIX = "10.0123";
        this.NAMESPACE_SEPARATOR = "depositOnce/";
    }
        
    @Override
    public boolean create(String identifier, DSpaceObject dso) throws IdentifierException {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public boolean reserve(String identifier, DSpaceObject dso) throws IdentifierException {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public String mint(DSpaceObject dso) throws IdentifierException {
        throw new UnsupportedOperationException("Not supported yet.");
    }

    @Override
    public boolean delete(String identifier) throws IdentifierException {
        throw new UnsupportedOperationException("Not supported yet.");
    }
    
    
    private Document crosswalkMetadata(DSpaceObject dso) throws CrosswalkException, IOException, SQLException, AuthorizeException {
        if ((null == dso) || !(dso instanceof Item))
            throw new IllegalArgumentException("Must be an Item");
        Item item = (Item) dso; // TODO generalize to DSO when all DSOs have metadata.
        
        
        // Get the DOI
        String doi = "";
        DCValue[] identifiers = item.getMetadata(DOIIdentifierProvider.MD_SCHEMA, DOIIdentifierProvider.DOI_ELEMENT, DOIIdentifierProvider.DOI_QUALIFIER, Item.ANY);
        for (DCValue identifier : identifiers) {
            if (identifier.value.startsWith(DOI.SCHEME)) {
                doi = identifier.value.substring(DOI.SCHEME.length());
                break;
            }
        }
        if (doi.isEmpty()) {
            log.error("Tried to convert metadta of an item without DOI into DataCite Schema. ID of item: {}.", dso.getID());
            throw new IllegalArgumentException("Tried to convert metadata of an item without doi into DataCite Schema.");
        }
        
        // TODO: check if all necessary metadata exists.
        
        if (null != this.crosswalk && this.crosswalk.canDisseminate(dso)) {
            try {
                Element root = this.crosswalk.disseminateElement(dso);
                return new Document(root);
            } catch (CrosswalkException ex) {
                log.error("Error using crosswalk to convert metadata into DataCite Schema. Caught: {}", ex.getMessage());
                throw ex;
            } catch (IOException ex) {
                log.error("Error using crosswalk to convert metadata into DataCite Schema. Caught: {}", ex.getMessage());
                throw ex;
            } catch (SQLException ex) {
                log.error("Error using crosswalk to convert metadata into DataCite Schema. Caught: {}", ex.getMessage());
                throw ex;
            } catch (AuthorizeException ex) {
                log.error("Error using crosswalk to convert metadata into DataCite Schema. Caught: {}", ex.getMessage());
                throw ex;
            }
        }
        else
        {
            log.error("The crosswalk '{}' is unitialized or unable to dissemination the item with the internal id {}.", this.CROSSWALK_NAME, dso.getID());
            throw new IllegalStateException("Crosswalk had been null or is unable to disseminate an item.");
        }
    }

}
